package main

import (
	"bytes"
	"context"
	"crypto/md5"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"

	"cloud.google.com/go/storage"
	"google.golang.org/api/iterator"
)

type Object map[string][]byte

type OperationType string

const (
	Add    OperationType = "ADD"
	Update OperationType = "UPDATE"
	Delete OperationType = "DELETE"
)

type Operation struct {
	Type OperationType
	Path string
}

func (o Operation) String() string {
	switch o.Type {
	case Add:
		return fmt.Sprintf("Add Operation: %s\n", o.Path)
	case Update:
		return fmt.Sprintf("Update Operation: %s\n", o.Path)
	case Delete:
		return fmt.Sprintf("Delete Operation: %s\n", o.Path)
	default:
		return ""
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	gcs, err := fetchStorageObjects(ctx)
	if err != nil {
		log.Fatalln(err)
	}
	local, err := fetchLocalFiles(ctx)
	if err != nil {
		log.Fatalln(err)
	}
	ops, err := compare(gcs, local)
	if err != nil {
		log.Fatalln(err)
	}
	for i := range ops {
		fmt.Fprintln(os.Stdout, ops[i].String())
	}
}

func fetchStorageObjects(ctx context.Context) (Object, error) {
	client, err := storage.NewClient(ctx)
	if err != nil {
		return nil, err
	}
	bucket := client.Bucket("veads-contents-dev")
	iter := bucket.Objects(ctx, &storage.Query{
		Versions:   false,
		Projection: storage.ProjectionNoACL,
	})
	objects := Object{}
	for {
		v, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}
		objects[v.Name] = v.MD5
	}
	return objects, nil
}

func fetchLocalFiles(ctx context.Context) (Object, error) {
	root := "../../dist/"
	objects := Object{}
	err := filepath.Walk("../../dist", func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		objects[strings.TrimPrefix(path, root)] = nil
		return nil
	})
	if err != nil {
		return nil, err
	}
	return objects, nil
}

func compare(remote, local Object) ([]Operation, error) {
	var ops []Operation
	for key := range local {
		if v, ok := remote[key]; ok {
			// If object exists in remote, calculate hash and compare
			hash, err := calculateHash(key)
			if err != nil {
				return nil, err
			}
			if !bytes.Equal(v, hash) {
				ops = append(ops, Operation{
					Type: Update,
					Path: key,
				})
			}
			continue
		}
		// If object not exists in remote, append to adding list
		ops = append(ops, Operation{
			Type: Add,
			Path: key,
		})
	}

	for key := range remote {
		if _, ok := local[key]; ok {
			continue
		}
		// Delete object on the remote
		ops = append(ops, Operation{
			Type: Delete,
			Path: key,
		})
	}

	return ops, nil
}

func calculateHash(key string) ([]byte, error) {
	fp, err := os.Open(filepath.Join("../../dist", key))
	if err != nil {
		return nil, err
	}
	defer fp.Close()
	buf, err := io.ReadAll(fp)
	if err != nil {
		return nil, err
	}
	hash := md5.Sum(buf)
	return hash[:], nil
}
